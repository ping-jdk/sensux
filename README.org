* A Client Will
- Have a set of attributes to describe it, including its responsibilities (generate w/ ohai/factor)
- Subscribe to a set of fanout exchanges base on its responsibilities (roles)
- Send keep alives to a server
- Execute a check and push the result and its client name to a direct exchange (named "results")

* A Server Will
- Populate an internal work queue from a JSON config file (generate with OpsChef/Puppet)
- Subscribe to a direct exchange (named "results")
- Pull a check from the internal work queue and then push it out onto its associated fanout exchanges (roles)
- Process results, storing the latest events (critical/warnings) for clients, a good result will flush a previous event for that client (resolve)
- Trigger the event handlers

* An API Will
- List events
- Remove a client and resolve any associated events
- List all clients and their subscriptions

* A Handler Will
- Accept a single command line argument for an event file path
- Parse the JSON event file
- Handle the event as it wishes

* A Dashboard Will
- Display all events (critical/warnings) (including additional check information; owner, notes, etc)
- Query OpsChef/Puppet for additional client (node) information

* Goals
** Friday, August 6th
- A Pagerduty handler (not paging)
- RabbitMQ authentication and SSL
- Reconnect on network failure
* Configure RabbitMQ
  user

  : rabbitmqctl add_user sa-monitoring password

  vhost

  : rabbitmqctl add_vhost /sa-monitoring

  permissions

  : rabbitmqctl set_permissions -p /sa-monitoring sa-monitoring ".*" ".*" ".*"

  /usr/local/etc/rabbitmq/rabbitmq.config

  : [
  :   {rabbit, [
  :     {ssl_listeners, [5671]},
  :     {ssl_options, [{cacertfile,"PATH/certs/sa-monitoring-ca/cacert.pem"},
  :                    {certfile,"PATH/certs/sa-monitoring-server/cert.pem"},
  :                    {keyfile,"PATH/certs/sa-monitoring-server/key.pem"},
  :                    {verify,verify_peer},
  :                    {fail_if_no_peer_cert,true}]}
  :   ]}
  : ].
