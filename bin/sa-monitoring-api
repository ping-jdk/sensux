#!/usr/bin/env ruby

$: << File.dirname(__FILE__) + '/../lib' unless $:.include?(File.dirname(__FILE__) + '/../lib/')
require 'sa-monitoring/config'
require 'sinatra/async'
require 'em-hiredis'

AMQP.start(:host => CONFIG['rabbitmq']['server']) do

  class ApiServer < Sinatra::Base
    register Sinatra::Async

    redis = EM::Hiredis.connect('redis://' + CONFIG['redis']['server'] + ':' + CONFIG['redis']['port'].to_s)

    amq = MQ.new
    result = amq.queue('results')

    #
    # Get all clients
    #
    aget '/clients' do
      content_type 'application/json'
      clients_info = Array.new
      redis.smembers('clients').callback do |clients|
        clients.each_with_index do |client, index|
          redis.get("client:#{client}").callback do |client_info|
            clients_info << JSON.parse(client_info)
            body clients_info.to_json if index == clients.size-1
          end
        end
      end
    end

    #
    # Get current events
    #
    aget '/alerts' do
      content_type 'application/json'
      client_alerts = Hash.new
      redis.smembers('clients').callback do |clients|
        clients.each_with_index do |client, index|
          redis.hgetall("alerts:#{client}").callback do |alerts|
            client_alerts.store(client, Hash[*alerts])
            body client_alerts.to_json if index == clients.size-1
          end
        end
      end
    end

    #
    # Remove a client and resolve its events
    #
    adelete '/client/:id' do |id|
      content_type 'application/json'
      redis.sismember('clients', id).callback do |client_exists|
        if client_exists != 0
          redis.exists("alerts:#{id}").callback do |alerts_exist|
            if alerts_exist != 0
              redis.hgetall("alerts:#{id}").callback do |alerts|
                Hash[*alerts].keys.each do |k|
                  result.publish({'check' => k, 'client' => id, 'status' => 0, 'output' => 'client is being removed from database...'}.to_json)
                  EM.add_timer(10) do
                    redis.srem("clients", id)
                    redis.del("alerts:#{id}")
                    redis.del("client:#{id}")
                  end
                end
              end
            else
              redis.srem("clients", id)
              redis.del("alerts:#{id}")
              redis.del("client:#{id}")
            end
            body({'success' => 'Client is being removed'}.to_json)
          end
        else
          status 404 # client doesn't exist
          body({'error' => 'Client not found'}.to_json)
        end
      end
    end
  end

  ApiServer.run!({:port => CONFIG['api']['port']})

  #
  # Recognize exit command
  #
  Signal.trap("INT") do
    EM.stop
  end
  Signal.trap("TERM") do
    EM.stop
  end
end
