#!/usr/bin/env ruby

$: << File.dirname(__FILE__) + '/../lib' unless $:.include?(File.dirname(__FILE__) + '/../lib/')
require 'sa-monitoring/config'
require 'amqp'
require 'em-hiredis'

#
# Connect to RabbitMQ
#
AMQP.start(:host => CONFIG['rabbitmq']['server']) do

  redis = EM::Hiredis.connect('redis://' + CONFIG['redis']['server'] + ':' + CONFIG['redis']['port'].to_s)

  amq = MQ.new

  #
  # Publish critical/warning check results
  #
  amq.queue('results').subscribe do |result|
    puts result
    response = JSON.parse(result)
    redis.get("check:#{response['id']}").callback do |id|
      check = JSON.parse(id)
      if response['status'] == 0
        redis.hexists("alerts:#{response['client']}", check['name']).callback do |exists|
          redis.hdel("alerts:#{response['client']}", check['name']) if exists
        end
      else
        redis.hset("alerts:#{response['client']}", check['name'], {'status' => response['status'], 'output' => response['output']}.to_json)
      end
    end
  end

  #
  # Send checks out to subscribed clients
  #
  exchanges = Hash.new

  amq.queue('checks').subscribe do |check|
    check = JSON.parse(check)

    check_id = UUIDTools::UUID.random_create.to_s

    redis.set("check:#{check_id}", {'name' => check['name'], 'timestamp' => Time.now.to_i}.to_json).callback do
      redis.sadd('checks', check_id)
    end

    check_msg = {
      'name' => check['name'],
      'id' => check_id
    }.to_json

    check['subscribers'].each do |exchange|

      if exchanges[exchange].nil?
        exchanges[exchange] = amq.fanout(exchange)
      end

      exchanges[exchange].publish(check_msg)
    end
  end

  #
  # Manually expire checks
  #
  EM.add_periodic_timer(300) do
    redis.smembers('checks').callback do |c|
      c.each do |check_id|
        redis.get("check:#{check_id}").callback do |check_data|
          check = JSON.parse(check_data)
          if check['timestamp'] < Time.now.to_i - 600
            redis.del("check:#{check_id}")
            redis.srem('checks', check_id)
          end
        end
      end
    end
  end

  #
  # Alert when a keep-alive hasn't been received in a defined amount of time
  #
  EM.add_periodic_timer(30) do
    redis.smembers('clients').callback do |c|
      c.each do |client_id|
        redis.get("client:#{client_id}").callback do |client_data|
          client = JSON.parse(client_data)
          time_since_last_check = Time.now.to_i - client['timestamp']
          if time_since_last_check >= 180 # critical
            redis.hset("alerts:#{client_id}", 'keepalive', {'status' => 2, 'output' => 'No keep-alive returned from host in over 180 seconds'}.to_json)
          elsif time_since_last_check >= 120 # warning
            redis.hset("alerts:#{client_id}", 'keepalive', {'status' => 1, 'output' => 'No keep-alive returned from host in over 120 seconds'}.to_json)
          else # healthy
            redis.hexists("alerts:#{client_id}", 'keepalive').callback do |exists|
              redis.hdel("alerts:#{client_id}", 'keepalive') if exists
            end
          end
        end
      end
    end
  end

  #
  # Populate the checks queue with checks defined in the JSON config file
  #
  check = amq.queue('checks')

  CONFIG['checks'].each_with_index do |(name, info), index|
    EM.add_timer(7*index) do
      EM.add_periodic_timer(info['interval']) do
        check.publish({'name' => name, 'subscribers' => info['subscribers']}.to_json)
      end
    end
  end

  #
  # Accept client keep-alives
  #
  class OhaiServer < EM::Connection
    attr_accessor :redis

    def receive_data(data)
      client = JSON.parse(data)['name']
      @redis.set("client:#{client}", data).callback do
        @redis.sadd('clients', client)
      end
    end
  end

  EM.start_server('0.0.0.0', 9000, OhaiServer) do |ohaiserver|
    ohaiserver.redis = redis
  end

  #
  # Recognize exit command
  #
  Signal.trap("INT") do
    EM.stop
  end
  Signal.trap("TERM") do
    EM.stop
  end
end
