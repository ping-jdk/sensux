#!/usr/bin/env ruby

$: << File.dirname(__FILE__) + '/../lib' unless $:.include?(File.dirname(__FILE__) + '/../lib/')
require 'sa-monitoring/config'
require 'amqp'
require 'em-hiredis'
require 'tempfile'

#
# Connect to RabbitMQ
#
AMQP.start(:host => CONFIG['rabbitmq']['server']) do

  redis = EM::Hiredis.connect('redis://' + CONFIG['redis']['server'] + ':' + CONFIG['redis']['port'].to_s)

  amq = MQ.new

  #
  # Accept client keep-alives
  #
  class OhaiServer < EM::Connection
    attr_accessor :redis

    def receive_data(client_json)
      client = JSON.parse(client_json)['name']
      @redis.set("client:#{client}", client_json).callback do
        @redis.sadd('clients', client)
      end
    end
  end

  EM.start_server('0.0.0.0', 9000, OhaiServer) do |ohaiserver|
    ohaiserver.redis = redis
  end

  #
  # Use custom handlers for events
  #
  def handle(event)
    event_file = proc do
      file = Tempfile.new('/tmp/sa-monitoring-event')
      file.print(JSON.pretty_generate(event))
      file.flush
      file.path
    end

    handlers = proc do |event_file|
      CONFIG['handlers'].each do |handler, command|
        EM.system('sh', '-c', command + ' -f ' + event_file  + ' 2>&1') do |output, status|
          puts handler
          puts status.exitstatus
          puts output
        end
      end
    end

    EM.defer(event_file, handlers)
  end

  #
  # Publish critical/warning check results
  #
  amq.queue('results').subscribe do |result_json|
    result = JSON.parse(result_json)
    redis.get("client:#{result['client']}").callback do |client_json|
      client = JSON.parse(client_json)
      event = {
        'client' => client,
        'check' => CONFIG['checks'][result['check']].merge('name' => result['check']),
        'status' => result['status'],
        'output' => result['output']
      }
      if result['status'] == 0
        redis.hexists("alerts:#{client['name']}", result['check']).callback do |exists|
          if exists == 1
            redis.hdel("alerts:#{client['name']}", result['check'])
            event['action'] = 'resolve'
            handle(event)
          end
        end
      else
        redis.hset("alerts:#{client['name']}", result['check'], {'status' => result['status'], 'output' => result['output']}.to_json).callback do
          event['action'] = 'create'
          handle(event)
        end
      end
    end
  end

  #
  # Send checks out to subscribed clients
  #
  exchanges = Hash.new

  amq.queue('checks').subscribe do |check_json|
    check = JSON.parse(check_json)

    check['subscribers'].each do |exchange|

      if exchanges[exchange].nil?
        exchanges[exchange] = amq.fanout(exchange)
      end

      exchanges[exchange].publish({'name' => check['name']}.to_json)
    end
  end

  #
  # Populate the checks queue with checks defined in the JSON config file
  #
  check = amq.queue('checks')

  CONFIG['checks'].each_with_index do |(name, info), index|
    EM.add_timer(7*index) do
      EM.add_periodic_timer(info['interval']) do
        check.publish({'name' => name, 'subscribers' => info['subscribers']}.to_json)
      end
    end
  end

  #
  # Alert when a keep-alive hasn't been received in a defined amount of time
  #
  EM.add_periodic_timer(30) do
    redis.smembers('clients').callback do |clients|
      clients.each do |client_id|
        redis.get("client:#{client_id}").callback do |client_json|
          client = JSON.parse(client_json)
          time_since_last_check = Time.now.to_i - client['timestamp']
          case
          when time_since_last_check >= 180
            redis.hset("alerts:#{client_id}", 'keepalive', {'status' => 2, 'output' => 'No keep-alive returned from host in over 180 seconds'}.to_json)
          when time_since_last_check >= 120
            redis.hset("alerts:#{client_id}", 'keepalive', {'status' => 1, 'output' => 'No keep-alive returned from host in over 120 seconds'}.to_json)
          else
            redis.hexists("alerts:#{client_id}", 'keepalive').callback do |exists|
              redis.hdel("alerts:#{client_id}", 'keepalive') if exists == 1
            end
          end
        end
      end
    end
  end

  #
  # Recognize exit command
  #
  Signal.trap("INT") do
    EM.stop
  end
  Signal.trap("TERM") do
    EM.stop
  end
end
