#!/usr/bin/env ruby

$: << File.dirname(__FILE__) + '/../lib' unless $:.include?(File.dirname(__FILE__) + '/../lib/')
require 'sa-monitoring/config'

#
# Connect to RabbitMQ
#
AMQP.start(symbolize_keys(CONFIG['rabbitmq'])) do |rabbitmq|

  amq = AMQP::Channel.new(rabbitmq)
  amq.auto_recovery = true

  #
  # Send keep-alives
  #
  keepalive = amq.queue('keepalives')

  keepalive.publish(CONFIG['client'].merge({'timestamp' => Time.now.to_i}).to_json)
  EM.add_periodic_timer(30) do
    keepalive.publish(CONFIG['client'].merge({'timestamp' => Time.now.to_i}).to_json)
  end

  #
  # Recieve checks, execute them, and publish results for processing
  #
  result = amq.queue('results')

  in_progress = Array.new

  CONFIG['client']['subscriptions'].each do |exchange|
    uniq_queue_name = UUIDTools::UUID.random_create.to_s
    amq.queue(uniq_queue_name, :auto_delete => true).bind(amq.fanout(exchange)).subscribe do |check_msg|
      check = JSON.parse(check_msg)
      unless in_progress.include?(check['name'])
        in_progress.push(check['name'])
        command = CONFIG['checks'][check['name']]['command'].gsub(/:::(.*?):::/, CONFIG['client'][ $1.to_s ].to_s)
        EM.system('sh', '-c', command + ' 2>&1') do |output, status|
          result.publish({'check' => check['name'], 'client' => CONFIG['client']['name'], 'status' => status.exitstatus, 'output' => output}.to_json)
          in_progress.delete(check['name'])
        end
      end
    end
  end

  #
  # Recognize exit command
  #
  Signal.trap("INT") do
    EM.stop
  end
  Signal.trap("TERM") do
    EM.stop
  end
end
