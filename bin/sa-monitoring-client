#!/usr/bin/env ruby

$: << File.dirname(__FILE__) + '/../lib' unless $:.include?(File.dirname(__FILE__) + '/../lib/')
require 'sa-monitoring/config'
require 'amqp'

#
# Connect to RabbitMQ
#
AMQP.start(:host => CONFIG['rabbitmq']['server']) do

  amq = MQ.new

  #
  # Send keep-alives to a worker
  #
  class OhaiClient < EM::Connection
    def post_init
      keep_alive = CONFIG['client'].merge({'timestamp' => Time.now.to_i})
      send_data(keep_alive.to_json)
      close_connection_after_writing
    end
  end

  EM.connect(CONFIG['workers'].sample, 9000, OhaiClient)
  EM.add_periodic_timer(30) do
    EM.connect(CONFIG['workers'].sample, 9000, OhaiClient)
  end

  #
  # Recieve checks, execute them, and publish results for processing
  #
  result = amq.queue('results')

  CONFIG['client']['subscriptions'].each do |exchange|

    uniq_queue_name = UUIDTools::UUID.random_create.to_s

    amq.queue(uniq_queue_name, :auto_delete => true).bind(amq.fanout(exchange)).subscribe do |check_msg|

      check = JSON.parse(check_msg)

      EM.system('sh', '-c', CONFIG['checks'][check['name']]['command'] + ' 2>&1') do |output, status|
        result.publish({'id' => check['id'], 'client' => CONFIG['client']['name'], 'status' => status.exitstatus, 'output' => output}.to_json)
      end
    end
  end

  #
  # Recognize exit command
  #
  Signal.trap("INT") do
    EM.stop
  end
  Signal.trap("TERM") do
    EM.stop
  end
end
